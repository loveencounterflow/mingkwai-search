// Generated by CoffeeScript 1.7.1
(function() {
  var ASYNC, COOKIE, DATASOURCES, DSREGISTRY, FILESEARCHER, LIMIT, MOJIKURA, O, STATIC, TRM, TYPES, alert, async_limit, badge, db, debug, echo, file_server, get_my_ip, handle_favicon, handle_static, help, info, limit_registry, log, log_static_requests, njs_http, njs_os, njs_path, njs_url, os_name, rpr, server, server_info, static_route, static_router, templates, warn,
    __slice = [].slice;

  require('coffee-script/register');

  njs_path = require('path');

  njs_os = require('os');

  njs_http = require('http');

  njs_url = require('url');

  TYPES = require('coffeenode-types');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = '明快main';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  templates = require('./templates');

  O = require('../options');

  MOJIKURA = require('coffeenode-mojikura');

  FILESEARCHER = require('./FILESEARCHER');

  DATASOURCES = require('jizura-datasources');

  DSREGISTRY = DATASOURCES.REGISTRY;

  db = MOJIKURA.new_db();


  /* https://github.com/dominictarr/my-local-ip */

  get_my_ip = require('my-local-ip');


  /* TAINT: this stuff should go into options */

  os_name = njs_os.platform();


  /* https://github.com/cloudhead/node-static */

  STATIC = require('node-static');

  static_route = './public';

  log_static_requests = true;

  file_server = new STATIC.Server(static_route);

  server = njs_http.createServer();

  server_info = server['info'] = {
    'os-name': os_name,
    'address': null,
    'port': null,
    'host': null,
    'routes': [],
    'started': null,
    'request-count': 0
  };

  if (os_name === 'darwin') {
    server_info['port'] = 80;
    server_info['host'] = get_my_ip();
  } else {
    server_info['port'] = 8080;
    server_info['host'] = '142.4.222.238';
  }

  server_info['address'] = "http://" + server_info['host'] + ":" + server_info['port'];


  /* https://github.com/caolan/async */

  ASYNC = require('async');

  async_limit = 5;


  /* https://github.com/aaronblohowiak/routes.js */

  static_router = (require('routes'))();

  COOKIE = require('cookie');

  this._cut_here_mark = '✂cut-here✂';

  this._cut_here_matcher = RegExp("<!--" + this._cut_here_mark + "-->");

  LIMIT = require('coffeenode-limit');

  limit_registry = LIMIT.new_registry();

  LIMIT.new_user(limit_registry, 'localhost', 'premium');

  LIMIT.new_user(limit_registry, '127.0.0.1', 'premium');

  LIMIT.new_user(limit_registry, server_info['host'], 'premium');

  handle_static = function(request, response, routing) {
    var filename, fileroute, static_fileroute;
    filename = routing['splats'][0];
    if (log_static_requests) {
      fileroute = njs_path.join(__dirname, static_route, filename);
    }
    static_fileroute = filename;
    request['url'] = static_fileroute;
    return file_server.serve(request, response);
  };

  handle_favicon = function(request, response, routing) {
    log(TRM.pink('favicon:', request['url']));
    request['url'] = 'favicon.ico';
    return file_server.serve(request, response);
  };

  static_router.addRoute('/public/*', handle_static);

  static_router.addRoute('/favicon.ico', handle_favicon);

  static_router.addRoute('/favicon.ico*', handle_favicon);

  this.write_http_head = function(response, status_code, cookie) {
    var headers, name, value;
    headers = {
      'Content-Type': 'text/html',
      'Connection': 'keep-alive',
      'Transfer-Encoding': 'chunked'
    };
    if (cookie != null) {
      headers['Cookie'] = (function() {
        var _results;
        _results = [];
        for (name in cookie) {
          value = cookie[name];
          _results.push(COOKIE.serialize(name, value));
        }
        return _results;
      })();
    }
    response.writeHead(status_code, headers);
    return null;
  };

  this.distribute = function(request, response) {
    var routing, uid, url;
    server['info']['request-count'] += 1;
    url = request['url'];
    if ((routing = static_router.match(url)) != null) {
      return routing['fn'](request, response, routing);
    }

    /* Limiting Access based on IP */
    uid = request.connection.remoteAddress;
    LIMIT.permesso(limit_registry, uid, (function(_this) {
      return function(error, ok, eta) {
        if (error != null) {
          throw error;
        }
        if (!ok) {
          return _this.refuse(request, response, uid, url, eta);
        }
        return _this.respond(request, response, uid, url);
      };
    })(this));
    return null;
  };

  this.refuse = function(request, response, uid, url, ms_to_wait) {
    this.write_http_head(response, 429);
    response.write(templates.refuse({
      'reason': "TOO MANY REQUESTS.",
      'ms-to-wait': ms_to_wait
    }));
    return response.end();
  };

  this.respond = function(request, response, uid, url) {
    var all_ds_infos, buffer, cookie, do_search_db, ds_infos, dsids, finalize_response, gids, html, html_front, html_rear, last_idx, last_query, parsed_url, q, result_count, route, rqid, search_db, search_ds_file, send_buffer, t0, tainted_languagecode, tasks, Δ, _ref, _ref1, _ref2;
    t0 = 1 * new Date();
    rqid = "RQ#" + server['info']['request-count'];
    parsed_url = njs_url.parse(url, true);
    route = parsed_url['pathname'];
    last_query = parsed_url['query'];
    q = (_ref = last_query['q']) != null ? _ref : null;
    Δ = response.write.bind(response);
    all_ds_infos = DSREGISTRY['ds-infos'];
    dsids = {};
    gids = {};
    ds_infos = [];
    do_search_db = last_query['db'] === 'db';
    if (request['headers']['cookie'] != null) {
      cookie = COOKIE.parse(request['headers']['cookie']);
    } else {
      cookie = {};
    }
    help('©34x', rqid, 'cookie:', cookie);
    help('©34x', rqid, 'url:   ', url);
    help('©34x', rqid, 'route: ', route);
    tainted_languagecode = (_ref1 = cookie['languagecode']) != null ? _ref1 : 'en_US';
    (function(_this) {
      return (function(dsid, ds_info, ds) {
        var _i, _len, _ref2, _results;
        ds = (_ref2 = last_query['ds']) != null ? _ref2 : [];
        if (!TYPES.isa_list(ds)) {
          ds = [ds];
        }
        _results = [];
        for (_i = 0, _len = ds.length; _i < _len; _i++) {
          dsid = ds[_i];
          ds_info = all_ds_infos[dsid];
          if (ds_info == null) {
            continue;
          }
          dsids[dsid] = 1;
          _results.push(ds_infos.push(ds_info));
        }
        return _results;
      });
    })(this)(null, null, null);

    /* TAINT code duplication */
    (function(_this) {
      return (function(gid, ds_info, dg) {
        var _i, _len, _ref2, _results;
        dg = (_ref2 = last_query['dg']) != null ? _ref2 : [];
        if (!TYPES.isa_list(dg)) {
          dg = [dg];
        }
        _results = [];
        for (_i = 0, _len = dg.length; _i < _len; _i++) {
          gid = dg[_i];
          if (DSREGISTRY['groupname-by-gid'][gid] == null) {
            continue;
          }
          _results.push(gids[gid] = 1);
        }
        return _results;
      });
    })(this)(null, null, null);
    log(TRM.green('©23k', rqid, last_query));
    html = templates.main({
      'rqid': rqid,
      'title': "明快搜字機 MingKwai Type Tool",
      'headline': "明快搜字機<br>MingKwai Type Tool",
      'results': [],
      'result-type': 'ag',
      'dt': 0,
      'last-query': last_query,
      'request-count': server['info']['request-count'],
      'db': do_search_db,
      'dsids': dsids,
      'gids': gids,
      'cut-here-mark': this._cut_here_mark,
      'languagecode': tainted_languagecode
    });
    _ref2 = html.split(this._cut_here_matcher), html_front = _ref2[0], html_rear = _ref2[1];
    if (html_rear == null) {
      throw new Error("unable to split HTML: no cut mark found");
    }
    result_count = 0;
    buffer = [];
    send_buffer = (function(_this) {
      return function() {
        var R;
        if ((R = buffer.length) !== 0) {
          Δ(buffer.join('\n'));
          buffer.length = 0;
          Δ(templates.update_result_count({
            result_nr: result_count,
            result_count: result_count
          }));
        }
        return R;
      };
    })(this);
    finalize_response = (function(_this) {
      return function() {
        send_buffer();
        Δ(html_rear);
        response.end();
        return warn('©23k', rqid, 'finished');
      };
    })(this);
    this.write_http_head(response, 200, cookie);
    Δ(html_front);
    last_idx = ds_infos.length - 1;
    if (last_idx < 0) {
      warn('©34w', rqid, "no data sources specified");
      return finalize_response();
    } else {
      log(TRM.green('©34w', rqid, "searching in " + ds_infos.length + " sources"));
      search_db = (function(_this) {
        return function(async_handler) {
          var id;
          id = "glyph:" + q;
          debug('©27t', id);
          return MOJIKURA.get(db, id, null, function(error, glyph_entry) {
            if (error != null) {
              return async_handler(error);
            }
            if (glyph_entry != null) {
              result_count += 1;
              buffer.push(templates.result_row({
                'rqid': rqid,
                'result': [glyph_entry],
                'result-type': 'db',
                'dsid': 'db',
                'result-nr': result_count,
                'result-count': result_count,
                'languagecode': tainted_languagecode
              }));
            }
            return async_handler(null, null);
          });
        };
      })(this);
      search_ds_file = (function(_this) {
        return function(ds_info, async_handler) {
          var ds_name, ds_route, dsid;
          dsid = ds_info['id'];
          ds_route = ds_info['route'];
          ds_name = ds_info['name'];
          return FILESEARCHER.search(ds_route, q, function(error, result) {
            if (error != null) {
              debug('XXXX' + error['message']);
            }
            if (result === null) {
              return async_handler(null, null);
            }
            result_count += 1;
            buffer.push(templates.result_row({
              'rqid': rqid,
              'result': result,
              'result-type': 'ds',
              'dsid': dsid,
              'result-nr': result_count,
              'result-count': result_count,
              'languagecode': tainted_languagecode
            }));
            if (buffer.length >= 2) {
              return send_buffer();
            }
          });
        };
      })(this);
      tasks = [];
      tasks.push((function(_this) {
        return function(handler) {
          return ASYNC.eachLimit(ds_infos, async_limit, search_ds_file, function(error) {
            return handler(error, null);
          });
        };
      })(this));
      if (do_search_db) {
        debug("searching in MojiKuraDB");
        tasks.push((function(_this) {
          return function(handler) {
            return search_db(function(error) {
              return handler(error, null);
            });
          };
        })(this));
      }
      ASYNC.parallel(tasks, finalize_response);
    }
    return null;
  };

  server.on('request', this.distribute.bind(this));

  server.on('close', (function(_this) {
    return function() {
      return warn("server " + server_address + " closed");
    };
  })(this));

  server.on('error', (function(_this) {
    return function(error) {
      alert("when trying to start serving on " + server_info['address'] + ", an error was encountered:");
      alert(rpr(error['message']));
      if (error['message'] === "listen EACCES" && server_info['port'] < 1024) {
        help("since the configured port is below 1024, you should probably");
        help("try and start the server using `sudo`");
      }
      throw error;
    };
  })(this));

  process.on('uncaughtException', function(error) {
    alert('uncaughtException');
    throw error;
  });

  this.start = function(handler) {
    var route;
    for (route in static_router.routeMap) {
      server_info['routes'].push(route);
    }
    return server.listen(server_info['port'], server_info['host'], (function(_this) {
      return function() {
        var P, error;
        error = arguments[0], P = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        server['info']['started'] = new Date();
        if (handler != null) {
          return handler(null, server_info);
        }
      };
    })(this));
  };

}).call(this);
